# UNIX IPC Server

Демон-сервер на языке C, демонстрирующий различные механизмы межпроцессного взаимодействия (IPC) в UNIX-системах.

## Содержание
- [Возможности](#-возможности)
- [Используемые механизмы IPC](#-используемые-механизмы-ipc)
- [Структура проекта](#-структура-проекта)
- [Требования](#-требования)
- [Сборка](#-сборка)
- [Использование](#-использование)
- [Детали реализации](#-детали-реализации)
- [Сигналы](#-сигналы)
- [Пример работы](#-пример-работы)
- [Очистка ресурсов](#-очистка-ресурсов)

## Возможности

- ✅ Прием запросов от клиентов через именованный канал (FIFO)
- ✅ Многопоточность
- ✅ Сбор статистики в разделяемой памяти
- ✅ Синхронизация через POSIX семафоры
- ✅ Идентификация клиентов по PID и UID
- ✅ Белый список ДОВЕРЕННЫХ пользователей
- ✅ Отдельная утилита для просмотра статистики

## Используемые механизмы IPC

| Механизм | Назначение |
|----------|------------|
| **FIFO** | Канал для приема запросов от клиентов |
| **Разделяемая память** (shm_open + mmap) | Хранение статистики сервера |
| **Семафоры** | Синхронизация доступа к статистике |
| **Сигналы** | Управление демоном (SIGTERM, SIGHUP) |
| **Pthreads** | Многопоточная обработка запросов |

## Структура проекта

```
unix-ipc-server/
├── ipc_server.c      # Основной сервер-демон
├── ipc_client.c      # Клиент для отправки запросов
├── stats_viewer.c    # Утилита для просмотра статистики
└── README.md         # Документация
```

## Требования

- UNIX-подобная ОС (Linux, macOS, FreeBSD)
- Компилятор с поддержкой C99 (gcc, clang)
- POSIX совместимая система

## Сборка

```bash
# Клонирование репозитория
git clone https://github.com/yourusername/unix-ipc-server.git
cd unix-ipc-server

# Компиляция всех компонентов
gcc -o ipc_server ipc_server.c -lpthread -lrt
gcc -o ipc_client ipc_client.c
gcc -o stats_viewer stats_viewer.c -lrt

# Или одной командой
make all  # если есть Makefile
```

## Использование

### 1. Запуск сервера

```bash
./ipc_server
```
Сервер автоматически уйдет в фон (станет демоном). Логи можно посмотреть в syslog:
```bash
tail -f /var/log/system.log  # macOS
tail -f /var/log/syslog      # Linux
```

### 2. Отправка запросов клиентом

```bash
./ipc_client
```
Клиент отправит тестовое сообщение и выведет свой PID.

### 3. Просмотр статистики

```bash
./stats_viewer
```
Пример вывода:
```
Общее кол-во запросов на сервер: 42
кол-во запросов uID = 0: 3
Последний PID клиента отправивший запрос: 7892

Ниже перечислены 10 последних PID'ов программ-клиентов:
7845:7892:7901:7912:7923:7934:7945:7956:7967:7978
```

## Детали реализации

### Сервер (ipc_server.c)

1. **Демонизация** (to_daemon):
   - `fork()` → родитель завершается
   - `setsid()` → новая сессия
   - `fork()` → второй потомок становится лидером сессии
   - `chdir("/")` → смена рабочего каталога
   - `umask(0)` → сброс маски прав
   - Закрытие всех файловых дескрипторов

2. **Защита от повторного запуска** (already_running):
   - PID-файл `/tmp/c_daemon.pid`
   - Блокировка через `fcntl()` с F_WRLCK

3. **Разделяемая память**:
   - `shm_open()` + `ftruncate()` + `mmap()`
   - Хранит структуру `ServerStats`:
     - `total_requests` - общее число запросов
     - `uid_counts[MAX_UIDS]` - счетчики по UID
     - `last_pids[10]` - кольцевой буфер последних PID
     - `last_index` - текущий индекс в буфере

4. **Семафор**:
   - Именованный семафор с именем на основе PID сервера
   - Защищает доступ к разделяемой памяти

5. **Обработка сигналов**:
   - Отдельный поток `sig_thr` ждет сигналы через `sigwait()`
   - `SIGTERM` - инициирует graceful shutdown
   - `SIGHUP` - зарезервирован для перезагрузки конфига

6. **Многопоточность**:
   - Основной поток читает FIFO через `poll()` с таймаутом
   - На каждый запрос создается detached-поток `handle_client`
   - Счетчик активных потоков для graceful shutdown

7. **Идентификация клиента**:
   - `get_uid_by_pid()` использует `sysctl()` (macOS) для получения UID по PID
   - Проверка по белому списку {0, 501, 502}

### Клиент (ipc_client.c)

- Открывает FIFO `/tmp/c_fifo` на запись
- Отправляет структуру с своим PID и сообщением
- Завершается после отправки

### Просмотр статистики (stats_viewer.c)

- Открывает существующую разделяемую память
- Читает и выводит статистику сервера

## Сигналы

| Сигнал | Действие |
|--------|----------|
| **SIGTERM** | Инициирует graceful shutdown (ждет завершения активных потоков) |
| **SIGHUP** | Логирует получение сигнала (зарезервировано для перезагрузки) |
| **Остальные** | Игнорируются или логируются |

## Очистка ресурсов

При завершении сервер автоматически удаляет:
- PID-файл `/tmp/c_daemon.pid`
- Разделяемую память `server_stats.file`
- Именованный семафор `/sem.<pid>`
- FIFO `/tmp/c_fifo` (удаляется при завершении последнего читателя)

## Пример логов (syslog)

```
Dec 25 10:15:30 c_daemon.1234: СЕРВЕР ЗАПУЩЕН
Dec 25 10:15:35 c_daemon.1234: Запрос клиента | PID: 7892 | UID: 501 | ДОВЕРИЕ | hello from Client =)
Dec 25 10:15:40 c_daemon.1234: Запрос клиента | PID: 7901 | UID: 1000 | НЕИЗВЕСТНЫЙ | hello from Client 2
Dec 25 10:16:00 c_daemon.1234: Получен сигнал SIGTERM - завершаюсь
Dec 25 10:16:00 c_daemon.1234: файл /tmp/c_daemon.pid удален
Dec 25 10:16:00 c_daemon.1234: файл server_stats.file удален
Dec 25 10:16:00 c_daemon.1234: файл-семафор /sem.1234 удален
Dec 25 10:16:00 c_daemon.1234: СЕРВЕР ЗАВЕРШИЛСЯ
```

## Примечания

- **macOS**: использует `sysctl()` для получения UID по PID
- **Linux**: потребуется адаптация через `/proc/[pid]/status`
- FIFO открывается в режиме `O_RDWR` чтобы избежать EOF при закрытии клиента
- Размер разделяемой памяти 1 МБ, хотя реально используется меньше (запас на будущее)

## Лицензия

MIT
